  \subsubsection{Secret Ballots}
  A vote encodes information about the eligibility of the voter, and
  information about the voter's preference. To determine the results of the
  elction while providing the verifiability properties discussed in
  Section~\ref{Subsection:verif}, there must be a public record of some
  aggregate information about each: An auditor must be able to tell that every
  voter was eligible, and also what the outcome of the election was. To provide
  voter confidentiality, we must provide a way for each voter to provide both
  bits of information without exposing the correlation between the two. In
  other words, if Badru wants to vote for Alicia to be president, Badru must
  convey that Badru (or someone with Badru's credentials) voted, and that a
  vote has been cast for Alicia, without revealing that Badru cast a vote for
  Alicia. We can represent the information Badru provides as a
  \emph{ballot}\todoword{make sure we're using ``ballot'' consistently - maybe
  petition?} tuple $(sig, vote)$, where $sig$ encodes Badru's credentials and
  $vote$ encodes his candidate choice.

  To provide the necessary information while preserving his
  confidentiality, Badru must encrypt part or all of his ballot.
  % We show
  % in Appendix~\ref{Appendix:SecretProof}\todosubst{I think this is actually
  % only true if people vote at different times} that it is impossible to design
  % a Byzantine Fault Tolerant protocol where both are kept secret. This leaves
  % two possibilities:
  Either Badru can encode his credentials in a $sig$ that is
  anonymous\cite{lrs}\todogrunt{talk about LRS/refer to it here}, or he can
  encrypt $vote$ so that Badru's choice of candidates can only be decyphered in
  aggregate, once the connection to Badru's public signature has been lost.

